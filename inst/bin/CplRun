#! /usr/bin/env Rscript
cmdargs <- commandArgs(TRUE);if(!interactive()&&("--help" %in% cmdargs)){cat("
NAME: CplRun - Run the covariate-dependent copula model

DESCRIPTION:

    An R script that performs the MCMC and cross-validation for covariate-dependent copula
    model.

USAGE:

    CplRun <nCores> <MdlConfigFile.R>

    CplRun --help

ARGUMENTS:

    <MdlConfigFile.R>: The copula configuration file. See example files under inst/config/.

    <nCores>: Number of total parallel processors used. The default value is one, i.e.

     using serial code.

     --help: Show the help file.

ENVIRONMENT:

     The script depends on the environment variable R_CPL_LIB_ROOT_DIR which points to the
     location of the copula code to be set properly before running the MCMC. One may set
     it in the .Renviron file under the $HOME directory.

     Make sure the file is executable and is available under $PATH environment so that the
     computer can find it if you are at non-interactive mode.

DETAILS:

    The code are parallelized with ``parallel'' and ``snow'' packages and not designed for
    Windows machine.

VERSION:

    Initial: Wed Jan 09 22:38:48 CET 2013 Current: Tue Jul 14 16:40:24 CST 2015

AUTHOR:

    Feng Li, Central University of Finance and Economics

");q("no")}
require("methods", quietly = TRUE)
###----------------------------------------------------------------------------
### MODEL CONFIGURE PATH
###----------------------------------------------------------------------------

R_CPL_LIB_ROOT_DIR <- Sys.getenv("R_CPL_LIB_ROOT_DIR")
if(nchar(R_CPL_LIB_ROOT_DIR) == 0L)
{
    stop("R_CPL_LIB_ROOT_DIR is not set properly!")
}

{
    if(interactive())
    { ## PASS INTERNALLY
        ## PATH TO THE MODEL CONFIGURATION FILE
        MdlConfigFile <- file.path(R_CPL_LIB_ROOT_DIR,
                                   ## "inst/config/config.BB7.SPLITT.SP100-SP600.R"
                                   ## "inst/config/config.BB7.LU.SPLITT.SP100-SP600.R"
                                   ## "inst/config/config.BB7.LU.SPLITTPOISSON.BABA-TEXTS.R"
                                   ## "inst/config/config.GUMBEL.GARCH.SP100-SP600.R"
                                   ## "inst/config/config.GUMBEL.STOCHVOL.SP100-SP600.R"
                                   ## "inst/config/config.GUMBEL.SPLITT.SP100-SP600.R"
                                   ## "inst/config/config.CLAYTON.SPLITT.SP100-SP600.R"
                                   ## "inst/config/config.MVT3.SPLITT.SP100-SP400-SP600.R"
                                   ## "inst/config/config.MVT3.DF.SPLITT.SP100-SP400-SP600.R"
                                   ## "inst/config/config.MVGARCH.R"

                                   "inst/config/config.BB7.LU.SPLITT.DGPDATA.R"
                                   )
        nCores <- 1 # Set to 1 for no parallelism
    }
    else
    {## Pass via command argument
        if((length(cmdargs) == 1L))
        {
            MdlConfigFile <- cmdargs
            nCores <- 1
        }
        else if ((length(cmdargs) == 2L))
        {
            MdlConfigFile <- cmdargs[2]
            nCores <- as.integer(cmdargs[1])
        }
        else
        {
            stop("Model configuration file required. Try the command with `--help` option.")
        }
    }
}
###----------------------------------------------------------------------------
### LOAD THE CODE LIBRARY AND INITIALIZE R ENVIRONMENT
###----------------------------------------------------------------------------

## Load dependences
## require("mvtnorm", quietly = TRUE)
## require("optimx", quietly = TRUE)
## require("Rmpfr", quietly = TRUE)

## Load the sourceDir tool
sys.source(file.path(R_CPL_LIB_ROOT_DIR, "R/flutils/sourceDir.R"),
           envir = .GlobalEnv)

## Load the whole Copula library
Cpl.source <- sourceDir(file.path(R_CPL_LIB_ROOT_DIR, "R"),
                        byte.compile = 0,
                        recursive = TRUE,
                        ignore.error = TRUE)


## Extract variables from configure files
obj <- ls()
source(MdlConfigFile, local = TRUE, echo = FALSE)
rm(list = setdiff(setdiff(ls(), obj), c("nCross", "Mdl.crossValidIdx", "LPDS")))


## Set Parallel Computing environment
R_CPL_NPARALLEL <- floor(nCores/nCross)

if(nCross>1 & nCores>1)
{
    ## We have enough cores to do parallelized cross-validation
    require("parallel", quietly = TRUE)
    require("snow", quietly = TRUE)
    cl4CV <- makeCluster(nCross, type = "MPI")
    ce4CV <- clusterEvalQ(cl4CV,{
        sourceDir(file.path(Sys.getenv("R_CPL_LIB_ROOT_DIR"), "R"),
                  byte.compile = 0,
                  recursive = TRUE,
                  ignore.error = TRUE)
        Sys.setenv(R_CPL_NPARALLEL = R_CPL_NPARALLEL)
    })
}else
{
    Sys.setenv(R_CPL_NPARALLEL = R_CPL_NPARALLEL)
}
###----------------------------------------------------------------------------
### MCMC
###----------------------------------------------------------------------------
## Recording starting time
Starting.time <- Sys.time()

if(nCross>1 & nCores>1)
{
    OUT.FITTED <- parLapply(cl4CV,
                            Mdl.crossValidIdx[["training"]],
                            CplMain,
                            MdlConfigFile = MdlConfigFile)
} else
{
    OUT.FITTED <- lapply(X = Mdl.crossValidIdx[["training"]],
                         FUN = CplMain,
                         MdlConfigFile = MdlConfigFile)
}

###----------------------------------------------------------------------------
### POSTERIOR INFERENCE, PREDICTION ETC
###----------------------------------------------------------------------------
## Calculate the LPDS
cat("Calculating predictions......")
OUT.PRED.LPDS <- list()
LPDS <- OUT.FITTED[[1]][["LPDS"]]
{if(nCross>1 & nCores >1)
 {
     Mdl.PredLst <- clusterMap(cl = cl4CV,
                               fun = logDensPred,
                               CplFitted = OUT.FITTED,
                               Mdl.Idx.testing = Mdl.crossValidIdx[["testing"]])
 } else
 {
     Mdl.PredLst <- mapply(FUN = logDensPred,
                           CplFitted = OUT.FITTED,
                           Mdl.Idx.testing = Mdl.crossValidIdx[["testing"]],
                           SIMPLIFY = FALSE)
 }
 if(length(LPDS)>1 || !is.null(LPDS))
 {
     for(iLPDS in LPDS)
     {
         OUT.PRED.LPDS[[iLPDS]] <- logPredDensScore(lapply(Mdl.PredLst, function(x) x[["Mdl.logPredDens"]][, iLPDS, drop = FALSE]))
     }
 }

 OUT.PRED.MVSK <- lapply(Mdl.PredLst, function(x) x[["MVSK"]])
 OUT.PRED.RESID <- lapply(Mdl.PredLst, function(x) x[["RESID"]])
 cat("done\n")
 print(OUT.PRED.LPDS)
###----------------------------------------------------------------------------
### FINISH THE WORK AND SAVE THE OUTPUT
###----------------------------------------------------------------------------

 ## Stop the parallel environment
 if(nCross>1 & nCores >1)
 {
     stopCluster(cl4CV)
 }
 save.all(save.output = OUT.FITTED[[1]][["save.output"]],
          ModelDescription = OUT.FITTED[[1]][["ModelDescription"]])
}

## Print warnings only in non-interactive mode
if(!interactive() && exists("last.warning",  envir  =  baseenv())) warnings()

## Quit
if(!interactive())q("no")
###----------------------------------------------------------------------------
### THE END
###----------------------------------------------------------------------------
