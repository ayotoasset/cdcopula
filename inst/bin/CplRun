#! /usr/bin/env Rscript
args <- commandArgs(TRUE); if(!interactive()&("--help" %in% args)){cat("
NAME:

    CplRun - Run the covariate-dependent copula model

DESCRIPTION:

    An R script that performs the MCMC and cross-validation for
    covariate-dependent copula model.

USAGE:

    CplRun <nCores> <CplConfigFile.R>
    CplRun --help

ARGUMENTS:

    <CplConfigFile.R>:

        The copula configuration file. See example files under inst/config/.

    <nCores>

       Number of total parallel processors used. The default value is one, i.e. using
       serial code.


    --help:

        Show the help file.

ENVIRONMENT:

     The script depends on the environment variable R_CPL_LIB_ROOT_DIR which points to the
     location of the copula code to be set properly before running the MCMC. One may set
     it in the .Renviron file under the $HOME directory.

     Make sure the file is executable and is available under $PATH environment so that the
     computer can find it if you are at non-interactive mode.

DETAILS:

    The code are parallelized with ``parallel'' and ``snow'' packages and not designed for
    Windows machine.

VERSION:

    Initial: Wed Jan 09 22:38:48 CET 2013
    Current: Tue Jul 14 16:40:24 CST 2015

AUTHOR:

    Feng Li, Central University of Finance and Economics

");q()}
require("methods", quietly = TRUE)
###----------------------------------------------------------------------------
### MODEL CONFIGURE PATH
###----------------------------------------------------------------------------

R_CPL_LIB_ROOT_DIR <- Sys.getenv("R_CPL_LIB_ROOT_DIR")
if(length(R_CPL_LIB_ROOT_DIR) == 0L)
{
  stop("R_CPL_LIB_ROOT_DIR is not set properly!")
}

{
  if(interactive())
    { ## PASS INTERNALLY
      ## PATH TO THE MODEL CONFIGURATION FILE
      CplConfigFile <- file.path(R_CPL_LIB_ROOT_DIR,
                                 "/inst/config/config.GUMBEL.GARCH.SP100-SP600.R")
      nCores <- 1
    }
  else
    {## Pass via command argument
      if((length(args) == 1L))
        {
          CplConfigFile <- args
          nCores <- 1
        }
      else if ((length(args) == 2L))
        {
          CplConfigFile <- args[2]
          nCores <- as.integer(args[1])
        }
      else
        {
          stop("Model configuration file required. Try --help.")
        }
    }
}

###----------------------------------------------------------------------------
### LOAD THE CODE LIBRARY AND INITIALIZE R ENVIRONMENT
###----------------------------------------------------------------------------

## Load dependences
require("mvtnorm", quietly = TRUE)
require("optimx", quietly = TRUE)
## Load the sourceDir tool
sys.source(file.path(R_CPL_LIB_ROOT_DIR, "R/flutils/sourceDir.R"),
           envir = .GlobalEnv)

## Load the whole Copula library
Cpl.source <- sourceDir(file.path(R_CPL_LIB_ROOT_DIR, "R"),
                        byte.compile = 0,
                        recursive = TRUE,
                        ignore.error = TRUE)


## Initialize R environment FIXME: bad structure
source(CplConfigFile, local = TRUE)


## Set Parallel Computing environment
R_CPL_NPARALLEL <- floor(nCores/nCross)

if(nCross>1 & nCores>1)
{
  ## We have enough cores to do parallelized cross-validation
  require("parallel", quietly = TRUE)
  require("snow", quietly = TRUE)
  cl4CV <- makeCluster(nCross, type = "MPI")
  ce4CV <- clusterEvalQ(
          cl4CV,{
            sourceDir(file.path(Sys.getenv("R_CPL_LIB_ROOT_DIR"), "R"),
                      byte.compile = 0,
                      recursive = TRUE,
                      ignore.error = TRUE)
            Sys.setenv(R_CPL_NPARALLEL = R_CPL_NPARALLEL)
          })
}else
{
  Sys.setenv(R_CPL_NPARALLEL = R_CPL_NPARALLEL)
}
###----------------------------------------------------------------------------
### MCMC
###----------------------------------------------------------------------------
## Recording starting time
Starting.time <- Sys.time()

if(nCross>1 & nCores>1)
{
  OUT.CplCross <- parLapply(
          cl4CV,
          crossValidIdx[["training"]],
          CplMain,
          CplConfigFile = CplConfigFile)
} else
{
  OUT.CplCross <- lapply(
          X = crossValidIdx[["training"]],
          FUN = CplMain,
          CplConfigFile = CplConfigFile)
}

###----------------------------------------------------------------------------
### POSTERIOR INFERENCE, PREDICTION ETC
###----------------------------------------------------------------------------

## Calculate the LPDS
LPDS.OUT <- list()
for(iLPDS in LPDS)
  {
    if(nCross>1 & nCores >1)
      {
        logPredLst <- clusterMap(
                cl = cl4CV,
                fun = logDensPred,
                CplOut = OUT.CplCross,
                pred = iLPDS,
                Mdl.Idx.testing = crossValidIdx[["testing"]])
      }
    else
      {
        logPredLst <- mapply(
                FUN = logPredDens,
                CplOut = OUT.CplCross,
                pred = iLPDS,
                Mdl.Idx.testing = crossValidIdx[["testing"]],
                SIMPLIFY = FALSE)
      }

    LPDS.OUT[[iLPDS]] <- logPredDensScore(logPredLst = logPredLst)
  }

###----------------------------------------------------------------------------
### FINISH THE WORK AND SAVE THE OUTPUT
###----------------------------------------------------------------------------

## Stop the parallel environment
if(nCross>1 & nCores >1)
  {
    stopCluster(cl4CV)
  }
save.all(save.output = save.output,
         ModelDescription = ModelDescription,
         Starting.time = Starting.time)

###----------------------------------------------------------------------------
### THE END
###----------------------------------------------------------------------------
