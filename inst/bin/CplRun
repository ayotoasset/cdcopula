#! /usr/bin/env Rscript
cmdargs <- commandArgs(TRUE);if(!interactive()&&("--help" %in% cmdargs)){cat("
NAME: CplRun - Run the covariate-dependent copula model

DESCRIPTION:

    An R script that performs the MCMC and cross-validation for covariate-dependent copula
    model.

USAGE:

    CplRun <nCores> <MdlConfigFile.R>

    CplRun --help

ARGUMENTS:

    <MdlConfigFile.R>: The copula configuration file. See example files under inst/config/.

    <nCores>: Number of total parallel processors used. The default value is one, i.e.

     using serial code.

     --help: Show the help file.

ENVIRONMENT:

     The script depends on the environment variable R_CPL_LIB_ROOT_DIR which points to the
     location of the copula code to be set properly before running the MCMC. One may set
     it in the ``.Renviron'' file under the $HOME directory.

     Make sure the file is executable and is available under $PATH environment so that the
     computer can find it if you are at non-interactive mode.

DETAILS:

    The code are parallelized with ``parallel'' and ``snow'' packages and not designed for
    Windows machine.

VERSION:

    Initial: Wed Jan 09 22:38:48 CET 2013 Current: Fri Jul 29 22:00:43 CST 2016

AUTHOR:

    Feng Li,

    Central University of Finance and Economics
    http://feng.li/
    feng.li@cufe.edu.cn

");q("no")}
require("methods", quietly = TRUE)
###----------------------------------------------------------------------------
### MODEL CONFIGURE PATH
###----------------------------------------------------------------------------

R_CPL_LIB_ROOT_DIR <- Sys.getenv("R_CPL_LIB_ROOT_DIR")
if(nchar(R_CPL_LIB_ROOT_DIR) == 0L)
{
    stop("R_CPL_LIB_ROOT_DIR is not set properly!")
}

{
    if(interactive())
    { ## PASS INTERNALLY
        ## PATH TO THE MODEL CONFIGURATION FILE
        MdlConfigFile <- file.path(R_CPL_LIB_ROOT_DIR,
                                   ## "inst/config/config.BB7.SPLITT.SP100-SP600.R"
                                   ## "inst/config/config.BB7.LU.SPLITT.SP100-SP600.R"
                                   ## "inst/config/config.BB7.LU.GARCH.SP100-SP600.R"
                                   ## "inst/config/config.BB7.LU.SPLITTPOISSON.BABA-TEXTS.R"
                                   ## "inst/config/config.GUMBEL.GARCH.SP100-SP600.R"
                                   ## "inst/config/config.GUMBEL.STOCHVOL.SP100-SP600.R"
                                   ## "inst/config/config.GUMBEL.SPLITT.SP100-SP600.R"
                                   ## "inst/config/config.CLAYTON.SPLITT.SP100-SP600.R"
                                   ## "inst/config/config.MVT3.SPLITT.SP100-SP400-SP600.R"
                                   ## "inst/config/config.MVT2.SPLITT.SP100-SP600.R"
                                   ## "inst/config/config.MVT3.DF.SPLITT.SP100-SP400-SP600.R"
                                   ##  "inst/config/config.MVGARCH.R"
                                   "inst/config/config.BB7.LU.SPLITT.DGPDATA.R"
                                   )
        nCores <- 1 # Set to 1 for no parallelism
    }
    else
    {## Pass via command argument
        if((length(cmdargs) == 1L))
        {
            MdlConfigFile <- cmdargs
            nCores <- 1
        }
        else if ((length(cmdargs) == 2L))
        {
            MdlConfigFile <- cmdargs[2]
            nCores <- as.integer(cmdargs[1])
        }
        else
        {
            stop("Model configuration file required. Try the command with `--help` option.")
        }
    }
}
###----------------------------------------------------------------------------
### LOAD THE CODE LIBRARY AND INITIALIZE R ENVIRONMENT
###----------------------------------------------------------------------------

## Load the sourceDir tool
sys.source(file.path(R_CPL_LIB_ROOT_DIR, "R/flutils/sourceDir.R"),
           envir = .GlobalEnv)

## Load the whole Copula library
Cpl.source <- sourceDir(file.path(R_CPL_LIB_ROOT_DIR, "R"),
                        byte.compile = 0,
                        recursive = TRUE,
                        ignore.error = TRUE)


## Extract variables from configure files
obj <- ls()
source(MdlConfigFile, local = TRUE)
###----------------------------------------------------------------------------
### PRINT MODEL DESCRIPTION
###----------------------------------------------------------------------------
cat(rep("-", getOption("width")-1), "\n", sep = "")
cat("MODEL DESCRIPTION\n")
cat(rep("-", getOption("width")-1), "\n", sep = "")


cat("nObsRaw:", nObsRaw, "\n")
cat("nObsUsed:", length(Mdl.dataUsedIdx), "\n")

cat("MCMC.nIter: ", MCMC.nIter,   "\n")
cat("MCMC.burninProp:", MCMC.burninProp, "\n")
cat("MCMC.UpateStrategy: ", MCMC.UpdateStrategy, "\n")

                                        # cat("nCross: ", nCross,  "\n")
cat("Mdl.crossValidArgs:\n")
print(unlist(Mdl.crossValidArgs))

## cat("Mdl.MargisNM: ", Mdl.MargisNM,   "\n")
cat("Mdl.MargisType:\n")
print(Mdl.MargisType)

if(all(rapply(Mdl.X, class)  == "matrix"))
{
    cat("No. of covariates used:\n")
    print(rapply(Mdl.X, ncol))
}
cat("Mdl.varSelArgs:\n")
print(unlist(Mdl.varSelArgs))
cat("MCMC.Update:\n")
print(unlist(MCMC.Update))
cat(rep("-", getOption("width")-1), "\n", sep = "")

## Remove unneeded variables
rm(list = setdiff(setdiff(ls(), obj),
                  c("nCross", "Mdl.crossValidIdx", "LPDS", "CplMCMC.summary")))

###----------------------------------------------------------------------------
### SETUP PARALLEL COMPUTING ENVIRONMENT
###----------------------------------------------------------------------------
if(nCross > 1 & nCores >1)
{
    R_CPL_NPARALLEL <- floor(nCores/nCross)

    if(R_CPL_NPARALLEL<1)
    {
        stop("No sufficient many cores (",  nCores,  ") for running ",  nCross,
             " cross-validations")
    }

} else
{
    R_CPL_NPARALLEL <- nCores
}

if(nCross>1 & nCores>1)
{
    ## We have enough cores to do parallelized cross-validation
    require("parallel", quietly = TRUE)
    require("snow", quietly = TRUE)
    require("Rmpi", quietly = TRUE) # mpi.quit("no")

    cl4CV <- makeCluster(nCross, type = "MPI")
    clusterExport(cl4CV, "R_CPL_NPARALLEL")
    ce4CV <- clusterEvalQ(cl4CV,{
        sourceDir(file.path(Sys.getenv("R_CPL_LIB_ROOT_DIR"), "R"),
                  byte.compile = 0,
                  recursive = TRUE,
                  ignore.error = TRUE)
        Sys.setenv(R_CPL_NPARALLEL = R_CPL_NPARALLEL)
    })
}else
{
    Sys.setenv(R_CPL_NPARALLEL = R_CPL_NPARALLEL)
}
###----------------------------------------------------------------------------
### RUN MCMC
###----------------------------------------------------------------------------
## Recording starting time
Starting.time <- Sys.time()

if(nCross>1 & nCores>1)
{
    OUT.FITTED <- parLapply(cl4CV,
                            Mdl.crossValidIdx[["training"]],
                            CplMain,
                            MdlConfigFile = MdlConfigFile)
} else
{
    OUT.FITTED <- lapply(X = Mdl.crossValidIdx[["training"]],
                         FUN = CplMain,
                         MdlConfigFile = MdlConfigFile)
}

###----------------------------------------------------------------------------
### POSTERIOR INFERENCE, PREDICTION ETC.
###----------------------------------------------------------------------------

## Final Summary of MCMC when paralleled.
if(nCross>1 & nCores >1)
{
    summary.Cpl <- list()
    for(iCross in 1:nCross)
    {   ## TODO: change the loop
        cat("iCross: ", iCross, "\n")
        summary.Cpl[[iCross]] <- CplMCMC.summary(OUT.FITTED[[iCross]])
    }
}


## Calculate the LPDS
cat("Calculating predictions......")
OUT.PRED.LPDS <- list()
LPDS <- OUT.FITTED[[1]][["LPDS"]]
{
    if(nCross>1 & nCores >1)
    {
        Mdl.PredLst <- clusterMap(cl = cl4CV,
                                  fun = logDensPred,
                                  CplFitted = OUT.FITTED,
                                  Mdl.Idx.testing = Mdl.crossValidIdx[["testing"]])
    } else
    {
        Mdl.PredLst <- mapply(FUN = logDensPred,
                              CplFitted = OUT.FITTED,
                              Mdl.Idx.testing = Mdl.crossValidIdx[["testing"]],
                              SIMPLIFY = FALSE)
    }
    if(length(LPDS)>1 || !is.null(LPDS))
    {
        for(iLPDS in LPDS)
        {   ## TODO: parallel
            OUT.PRED.LPDS[[iLPDS]] <- logPredDensScore(
                lapply(Mdl.PredLst, function(x) x[["Mdl.logPredDens"]][, iLPDS, drop = FALSE]))
        }
    }

    OUT.PRED.MVSK <- lapply(Mdl.PredLst, function(x) x[["Mdl.PredMVSK"]])
    OUT.PRED.RESID <- lapply(Mdl.PredLst, function(x) x[["Mdl.PredRESID"]])
    cat("done\n")
    print(OUT.PRED.LPDS)
###----------------------------------------------------------------------------
### FINISH THE WORK AND SAVE THE OUTPUT
###----------------------------------------------------------------------------
    ## Stop the parallel environment
    if(nCross>1 & nCores >1)
    {
        stopCluster(cl4CV)
    }
    save.all(save.output = OUT.FITTED[[1]][["save.output"]],
             ModelDescription = OUT.FITTED[[1]][["ModelDescription"]])
}

## Print warnings only in non-interactive mode
if(!interactive() && exists("last.warning",  envir  =  baseenv())) warnings()

## Quit (with mpi_finalize check)
if(!interactive())
{
    if(nCross>1 & nCores >1)
    {
        mpi.quit("no")
    } else
    {
        q("no")
    }
}

###----------------------------------------------------------------------------
### THE END
###----------------------------------------------------------------------------
